import logging
import click
import docker
import sys
from typing import Dict, List
import click_log

logger = logging.getLogger(__name__)
click_log.basic_config(logger)

HOSTS_FILE_START_MARKER = "# ! docker-hosts-update start !"
HOSTS_FILE_END_MARKER = "# ! docker-hosts-update end   !"


def map_hosts() -> Dict[str, List[str]]:
    """Returns dictionary"""
    client = docker.from_env()
    networks = client.networks.list()
    host_map = dict()
    for network in networks:
        network.reload()
        for _, value in network.attrs['Containers'].items():
            ip_without_mask = value['IPv4Address'][:value['IPv4Address'].index('/')]
            hostname = f'{value["Name"]}.{network.name}'
            if hostname not in host_map:
                host_map[hostname] = []
            host_map[hostname].append(ip_without_mask)
    return host_map


def update_hosts_file(filename: str):
    host_map = map_hosts()
    lines = []
    for hostname, ips in host_map.items():
         for ip in ips:
            lines.append(f'{ip}   {hostname}')
            
    content = "\n".join(lines)
    hosts_file_section = f"""{HOSTS_FILE_START_MARKER}
# This section was automatically generated by docker-hosts-update
# Don't edit this part manually :)
{content}
{HOSTS_FILE_END_MARKER}"""
    try:
        with open(filename, 'r') as hostsfile:
            original_host_file = hostsfile.read()
    except PermissionError:
        logging.error(f'Did not have permission to read {filename}.')
        return False

    start = original_host_file.find(HOSTS_FILE_START_MARKER)
    end = original_host_file.find(HOSTS_FILE_END_MARKER) + len(HOSTS_FILE_END_MARKER) 
    if start > -1 and end > -1:
        logging.debug('Found previously generated section, will attempt to replace.')
        new_host_file = original_host_file[:start] + hosts_file_section + \
        original_host_file[end:]
    else:
        logger.debug('Found no previously generated section, will append.')
        new_host_file = original_host_file + hosts_file_section

    try: 
        with open(filename, 'w') as hostsfile:
            original_host_file = hostsfile.write(new_host_file)
            logger.info(f'Wrote new {filename}')
    except PermissionError:
        logger.error(f'Did not have permission to write to {filename}.')
        return False
    
    return True


# Events that trigger the host file being updated.
TRIGGERING_DOCKER_EVENTS = [
    {'status': 'start', 'Type': 'container'},
    {'status': 'stop', 'Type': 'container'},
    {'status': 'die', 'Type': 'container'},
    {'status': 'destroy', 'Type': 'container'},
]


def _triggering_event(event: dict):
    for trigger in TRIGGERING_DOCKER_EVENTS:
        if all(event.get(key) == val for key, val in trigger.items()):
            return trigger


@click.command()
@click.option('--hosts-file', default='/etc/hosts', help='The hosts file to update.')
@click.option('--once', default=False, help='Run the update script once only.', is_flag=True)
@click.option('--initial', default=True, help='Run the update script one time before hooking into the docker event stream.', is_flag=True)
@click_log.simple_verbosity_option(logger)
def main(hosts_file: str, initial: bool, once: bool):
    client = docker.from_env()
    if initial or once:
        if not update_hosts_file(hosts_file):
            logger.error(f'Failed to update hosts in {hosts_file}')
            return -1
            
    if once:
        return 0

    for event in client.events(decode=True):
        logger.debug(f'Docker event: {event}')

        trigger = _triggering_event(event)
        if not trigger:
            logger.debug(f'Was not a triggering event. Skipping.')
            continue

        logger.info(f'Got triggering event. type={trigger["Type"]} status={trigger["status"]}')
        if not update_hosts_file(hosts_file):
            return -1


if __name__ == "__main__":
    sys.exit(main()) # pylint: disable=E1120
